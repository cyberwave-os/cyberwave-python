"""
Resource managers for Cyberwave API entities.

This module provides manager classes that wrap the auto-generated REST API
stubs with cleaner, more Pythonic interfaces.

Architecture:
    rest/           # Auto-generated by OpenAPI (NEVER edit manually)
    managers/       # Re-exports these managers (for future modular structure)
    resources.py    # The actual manager implementations (this file)

The managers are safe to edit - they wrap the auto-generated stubs and won't
be overwritten by regenerating the SDK.

Usage:
    These managers are typically accessed via the Cyberwave client:

    >>> client = Cyberwave(token="...")
    >>> workspaces = client.workspaces.list()
    >>> twin = client.twins.get("uuid")
"""

from typing import List, Optional, Dict, Any

from cyberwave.rest import (
    DefaultApi,
    WorkspaceSchema,
    WorkspaceResponseSchema,
    WorkspaceUpdateSchema,
    WorkspaceCreateSchema,
    ProjectSchema,
    ProjectCreateSchema,
    EnvironmentSchema,
    EnvironmentCreateSchema,
    AssetSchema,
    AssetCreateSchema,
    AssetUpdateSchema,
    TwinSchema,
    TwinCreateSchema,
    TwinStateUpdateSchema,
    JointStatesSchema,
    JointStateUpdateSchema,
    JointStateSchema,
    EdgeDeviceSchema,
)

from .exceptions import CyberwaveAPIError


class BaseResourceManager:
    """Base class for resource managers"""

    def __init__(self, api_client: DefaultApi):
        self.api = api_client

    def _handle_error(self, e: Exception, operation: str):
        """Handle API errors consistently"""
        if hasattr(e, "status"):
            body = getattr(e, "body", None)
            response_dict = body if isinstance(body, dict) else None

            # Try to extract request headers if available
            request_headers = None
            if hasattr(e, "request_headers"):
                request_headers = e.request_headers

            raise CyberwaveAPIError(
                f"Failed to {operation}: {str(e)}",
                status_code=int(e.status) if hasattr(e.status, "__int__") else None,
                response_data=response_dict,
                request_headers=request_headers,
            )
        raise CyberwaveAPIError(f"Failed to {operation}: {str(e)}")


class WorkspaceManager(BaseResourceManager):
    """Manager for workspace operations"""

    def list(self) -> List[WorkspaceSchema]:
        """List all workspaces"""
        try:
            response = self.api.src_users_api_workspaces_list_workspaces()
            return response
        except Exception as e:
            self._handle_error(e, "list workspaces")
            raise  # For type checker

    def get(self, workspace_id: str) -> WorkspaceResponseSchema:
        """Get workspace by ID"""
        try:
            return self.api.src_users_api_workspaces_get_workspace(workspace_id)
        except Exception as e:
            self._handle_error(e, f"get workspace {workspace_id}")
            raise  # For type checker

    def update(self, workspace_id: str, data: Dict[str, Any]) -> WorkspaceSchema:
        """Update workspace"""
        try:
            update_schema = WorkspaceUpdateSchema(**data)
            result = self.api.src_users_api_workspaces_update_workspace(
                workspace_id, update_schema
            )
            return result
        except Exception as e:
            self._handle_error(e, f"update workspace {workspace_id}")
            raise  # For type checker

    def create(self, name: str, description: str = "", **kwargs) -> WorkspaceSchema:
        """Create a new workspace"""
        try:
            create_schema = WorkspaceCreateSchema(
                name=name, description=description, **kwargs
            )
            return self.api.src_users_api_workspaces_create_workspace(create_schema)
        except Exception as e:
            self._handle_error(e, "create workspace")
            raise  # For type checker


class ProjectManager(BaseResourceManager):
    """Manager for project operations"""

    def list(self, workspace_id: Optional[str] = None) -> List[ProjectSchema]:
        """List all projects, optionally filtered by workspace"""
        try:
            return self.api.src_app_api_projects_list_projects()
        except Exception as e:
            self._handle_error(e, "list projects")
            raise  # For type checker

    def get(self, project_id: str) -> ProjectSchema:
        """Get project by ID"""
        try:
            return self.api.src_app_api_projects_get_project(project_id)
        except Exception as e:
            self._handle_error(e, f"get project {project_id}")
            raise  # For type checker

    def create(
        self, name: str, workspace_id: str, description: str = "", **kwargs
    ) -> ProjectSchema:
        """Create a new project"""
        try:
            create_schema = ProjectCreateSchema(
                name=name,
                description=description,
                workspace_uuid=workspace_id,
                **kwargs,
            )
            return self.api.src_app_api_projects_create_project(create_schema)
        except Exception as e:
            self._handle_error(e, "create project")
            raise  # For type checker

    def delete(self, project_id: str) -> None:
        """Delete a project"""
        try:
            self.api.src_app_api_projects_delete_project(project_id)
        except Exception as e:
            self._handle_error(e, f"delete project {project_id}")


class EnvironmentManager(BaseResourceManager):
    """Manager for environment operations"""

    def list(self, project_id: Optional[str] = None) -> List[EnvironmentSchema]:
        """List all environments, optionally filtered by project"""
        try:
            if project_id:
                return self.api.src_app_api_environments_list_environments_for_project(
                    project_id
                )
            else:
                return self.api.src_app_api_environments_list_all_environments()
        except Exception as e:
            self._handle_error(e, "list environments")
            raise  # For type checker

    def get(self, environment_id: str) -> EnvironmentSchema:
        """Get environment by ID"""
        try:
            return self.api.src_app_api_environments_get_environment(environment_id)
        except Exception as e:
            self._handle_error(e, f"get environment {environment_id}")
            raise  # For type checker

    def create(
        self, name: str, project_id: str | None = None, description: str = "", **kwargs
    ) -> EnvironmentSchema:
        """Create a new environment"""
        try:
            # if no project is speficied, grab the first project from the user. If the user has no projects, create a default project.
            if not project_id:
                project_id = self.api.src_app_api_projects_list_projects()[0].uuid
            if not project_id:
                project = self.api.src_app_api_projects_create_project(
                    ProjectCreateSchema(
                        name="Default Project",
                        description="Default Project Description",
                    )
                )
                project_id = project.uuid
            create_schema = EnvironmentCreateSchema(
                name=name, description=description, **kwargs
            )
            return self.api.src_app_api_environments_create_environment_for_project(
                project_id, create_schema
            )
        except Exception as e:
            self._handle_error(e, "create environment")
            raise  # For type checker

    def delete(self, environment_id: str, project_id: str) -> None:
        """Delete an environment"""
        try:
            self.api.src_app_api_environments_delete_environment_for_project(
                project_id, environment_id
            )
        except Exception as e:
            self._handle_error(e, f"delete environment {environment_id}")

    def get_twins(self, environment_id: str) -> List["TwinSchema"]:
        """Get all twins in an environment"""
        try:
            return self.api.src_app_api_environments_get_environment_twins(
                environment_id
            )
        except Exception as e:
            self._handle_error(e, f"get twins for environment {environment_id}")
            raise  # For type checker

    def get_first_or_none(self) -> Optional["EnvironmentSchema"]:
        """Get the first available environment, or None if no environments exist.

        Useful for CLI commands that need to select a default environment.

        Returns:
            First EnvironmentSchema or None if no environments exist.
        """
        try:
            environments = self.list()
            return environments[0] if environments else None
        except Exception:
            return None


class AssetManager(BaseResourceManager):
    """Manager for asset operations"""

    def __init__(self, api_client: DefaultApi):
        super().__init__(api_client)
        # Instance-level cache for full asset data to avoid repeated fetches
        # Using instance-level prevents cross-client contamination when multiple
        # Cyberwave clients are instantiated
        self._asset_cache: Dict[str, AssetSchema] = {}
        self._cache_timestamps: Dict[str, float] = {}
        self._cache_ttl: float = 60.0  # Cache TTL in seconds

    def _get_cached(self, asset_uuid: str) -> Optional[AssetSchema]:
        """Get asset from cache if not expired."""
        import time

        if asset_uuid in self._asset_cache:
            if (
                time.time() - self._cache_timestamps.get(asset_uuid, 0)
                < self._cache_ttl
            ):
                return self._asset_cache[asset_uuid]
        return None

    def _set_cache(self, asset_uuid: str, asset: AssetSchema) -> None:
        """Add asset to cache."""
        import time

        self._asset_cache[asset_uuid] = asset
        self._cache_timestamps[asset_uuid] = time.time()

    def list(self, workspace_id: Optional[str] = None) -> List[AssetSchema]:
        """List all assets, optionally filtered by workspace"""
        try:
            return self.api.src_app_api_assets_list_assets()
        except Exception as e:
            self._handle_error(e, "list assets")
            raise  # For type checker

    def get(self, asset_id: str) -> AssetSchema:
        """Get asset by ID"""
        try:
            return self.api.src_app_api_assets_get_asset(asset_id)
        except Exception as e:
            self._handle_error(e, f"get asset {asset_id}")
            raise  # For type checker

    def create(self, name: str, description: str = "", **kwargs) -> AssetSchema:
        """Create a new asset"""
        try:
            create_schema = AssetCreateSchema(
                name=name, description=description, **kwargs
            )
            return self.api.src_app_api_assets_create_asset(create_schema)
        except Exception as e:
            self._handle_error(e, "create asset")
            raise  # For type checker

    def update(self, asset_id: str, data: Dict[str, Any]) -> AssetUpdateSchema:
        """Update an asset"""
        try:
            update_schema = AssetUpdateSchema(**data)
            return self.api.src_app_api_assets_update_asset(asset_id, update_schema)
        except Exception as e:
            self._handle_error(e, f"update asset {asset_id}")
            raise  # For type checker

    def delete(self, asset_id: str) -> None:
        """Delete an asset"""
        try:
            self.api.src_app_api_assets_delete_asset(asset_id)
        except Exception as e:
            self._handle_error(e, f"delete asset {asset_id}")

    def search(self, query: str) -> List[AssetSchema]:
        """Search for assets by name or tags"""
        try:
            _param = self.api.api_client.param_serialize(
                method="GET",
                resource_path="/api/v1/assets",
                query_params=[("search", query)],
            )

            _response_types_map = {
                "200": "List[AssetSchema]",
            }

            response_data = self.api.api_client.call_api(*_param)
            response_data.read()

            return self.api.api_client.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            ).data
        except Exception as e:
            self._handle_error(e, "search assets")
            raise  # For type checker

    def get_by_registry_id(self, registry_id: str) -> Optional[AssetSchema]:
        """Get asset by registry ID (e.g., 'cyberwave/ip-camera').

        Uses search API first for efficiency, falls back to list scan.
        """
        try:
            # Try search API first (more efficient)
            search_results = self.search(registry_id)
            for asset in search_results:
                if getattr(asset, "registry_id", None) == registry_id:
                    return asset

            # Fall back to full list scan if not found in search
            assets = self.list()
            for asset in assets:
                if getattr(asset, "registry_id", None) == registry_id:
                    return asset
            return None
        except Exception:
            return None

    def get_by_alias(self, alias: str) -> Optional[AssetSchema]:
        """Get asset by alias defined in metadata.aliases.

        Optimized to minimize API calls:
        1. First checks for exact name match (no extra queries)
        2. Uses search API to find candidates
        3. Only fetches full details for top candidates (max 5)
        4. Uses caching to avoid repeated fetches

        Args:
            alias: Alias to search for (case-insensitive)

        Returns:
            AssetSchema if found, None otherwise
        """
        try:
            alias_lower = alias.lower()

            # Step 1: Try search API - often returns relevant results
            search_results = self.search(alias)

            # Check search results for exact name match first (no extra query)
            for asset in search_results:
                name = getattr(asset, "name", "").lower()
                if name == alias_lower:
                    # Get full asset to ensure we have complete data
                    asset_uuid = str(getattr(asset, "uuid", ""))
                    cached = self._get_cached(asset_uuid)
                    if cached:
                        return cached
                    full_asset = self.get(asset_uuid)
                    self._set_cache(asset_uuid, full_asset)
                    return full_asset

            # Step 2: Check aliases in search results (limit to top 5 to avoid N+1)
            candidates = search_results[:5]
            for asset in candidates:
                asset_uuid = str(getattr(asset, "uuid", ""))
                if not asset_uuid:
                    continue

                # Check cache first
                cached = self._get_cached(asset_uuid)
                if cached:
                    full_metadata = getattr(cached, "metadata", {}) or {}
                    aliases = full_metadata.get("aliases", [])
                    if any(a.lower() == alias_lower for a in aliases):
                        return cached
                    continue

                # Fetch full asset to check aliases
                full_asset = self.get(asset_uuid)
                self._set_cache(asset_uuid, full_asset)
                full_metadata = getattr(full_asset, "metadata", {}) or {}
                aliases = full_metadata.get("aliases", [])
                if any(a.lower() == alias_lower for a in aliases):
                    return full_asset

            # Step 3: If not found in search results, scan full list for name match
            # This handles cases where search didn't return the asset
            assets = self.list()
            for asset in assets:
                name = getattr(asset, "name", "").lower()
                if name == alias_lower:
                    asset_uuid = str(getattr(asset, "uuid", ""))
                    cached = self._get_cached(asset_uuid)
                    if cached:
                        return cached
                    full_asset = self.get(asset_uuid)
                    self._set_cache(asset_uuid, full_asset)
                    return full_asset

            return None
        except Exception:
            return None


class TwinManager(BaseResourceManager):
    """Manager for digital twin operations"""

    def __init__(self, api_client, client=None):
        super().__init__(api_client)
        self._client = client

    def list(self, environment_id: Optional[str] = None) -> List[TwinSchema]:
        """List all twins, optionally filtered by environment"""
        try:
            if environment_id:
                return self.api.src_app_api_environments_get_environment_twins(
                    environment_id
                )
            else:
                return self.api.src_app_api_twins_list_all_twins()
        except Exception as e:
            self._handle_error(e, "list twins")
            raise  # For type checker

    def get(self, twin_id: str):
        """Get twin by ID. Returns a Twin object with motion/navigation handles."""
        try:
            twin_data = self.api.src_app_api_twins_get_twin(twin_id)
            if self._client:
                from .twin import create_twin

                return create_twin(self._client, twin_data)
            return twin_data
        except Exception as e:
            self._handle_error(e, f"get twin {twin_id}")
            raise  # For type checker

    def get_raw(self, twin_id: str) -> TwinSchema:
        """Get raw twin data by ID (returns TwinSchema)"""
        try:
            return self.api.src_app_api_twins_get_twin(twin_id)
        except Exception as e:
            self._handle_error(e, f"get twin {twin_id}")
            raise  # For type checker

    def create(self, asset_id: str, environment_id: str, **kwargs) -> TwinSchema:
        """Create a new twin instance"""
        try:
            create_schema = TwinCreateSchema(
                asset_uuid=asset_id, environment_uuid=environment_id, **kwargs
            )
            return self.api.src_app_api_twins_create_twin(create_schema)
        except Exception as e:
            self._handle_error(e, "create twin")
            raise  # For type checker

    def update_state(self, twin_id: str, data: Dict[str, Any]) -> TwinSchema:
        """Update twin state (position, rotation, scale)"""
        try:
            update_schema = TwinStateUpdateSchema(**data)
            return self.api.src_app_api_twins_update_twin_state(twin_id, update_schema)
        except Exception as e:
            self._handle_error(e, f"update twin state {twin_id}")
            raise  # For type checker

    def update(self, twin_id: str, **kwargs) -> TwinSchema:
        """Update twin metadata and other fields.

        Uses the auto-generated REST API method for PUT /api/v1/twins/{uuid}.
        The backend accepts TwinCreateSchema for updates.

        Args:
            twin_id: UUID of the twin to update
            **kwargs: Fields to update (name, description, metadata, capabilities, etc.)

        Returns:
            Updated TwinSchema
        """
        try:
            # The backend uses TwinCreateSchema for PUT /twins/{uuid}
            update_schema = TwinCreateSchema(**kwargs)
            return self.api.src_app_api_twins_update_twin(twin_id, update_schema)
        except Exception as e:
            self._handle_error(e, f"update twin {twin_id}")
            raise  # For type checker

    def delete(self, twin_id: str) -> None:
        """Delete a twin"""
        try:
            self.api.src_app_api_twins_delete_twin(twin_id)
        except Exception as e:
            self._handle_error(e, f"delete twin {twin_id}")

    def get_joint_states(self, twin_id: str) -> JointStatesSchema:
        """Get current joint states for a twin"""
        try:
            return self.api.src_app_api_urdf_get_twin_joint_states(twin_id)
        except Exception as e:
            self._handle_error(e, f"get joint states for twin {twin_id}")
            raise  # For type checker

    def update_joint_state(
        self,
        twin_id: str,
        joint_name: str,
        position: float,
        velocity: Optional[float] = None,
        effort: Optional[float] = None,
    ) -> JointStateSchema:
        """Update a single joint state"""
        try:
            update_schema = JointStateUpdateSchema(
                position=position, velocity=velocity, effort=effort
            )
            return self.api.src_app_api_urdf_update_twin_joint_state(
                twin_id, joint_name, update_schema
            )
        except Exception as e:
            self._handle_error(e, f"update joint state for twin {twin_id}")
            raise  # For type checker

    # =========================================================================
    # Edge Device Pairing
    # =========================================================================

    def pair_device(
        self,
        twin_id: str,
        fingerprint: str,
        hostname: str = "",
        platform: str = "",
        edge_config: Optional[Dict[str, Any]] = None,
    ) -> "EdgeDeviceSchema":
        """
        Pair an edge device to this twin.

        Registers the device with the backend using its fingerprint.
        A device can only be paired to one twin at a time.

        Args:
            twin_id: UUID of the twin to pair with
            fingerprint: Stable device fingerprint (from generate_fingerprint())
            hostname: Device hostname (optional)
            platform: Device platform (e.g., 'Darwin-arm64')
            edge_config: Device configuration (cameras, models, etc.)

        Returns:
            EdgeDeviceSchema with device details

        Raises:
            ApiException: If device is already paired to a different twin (409)
        """
        from cyberwave.rest.models.pair_device_schema import PairDeviceSchema

        try:
            payload = PairDeviceSchema(
                fingerprint=fingerprint,
                hostname=hostname,
                platform=platform,
                edge_config=edge_config or {},
            )
            return self.api.src_app_api_twins_pair_device(twin_id, payload)
        except Exception as e:
            self._handle_error(e, f"pair device to twin {twin_id}")
            raise

    def list_devices(self, twin_id: str) -> List["EdgeDeviceSchema"]:
        """
        List all edge devices paired to this twin.

        Args:
            twin_id: UUID of the twin

        Returns:
            List of EdgeDeviceSchema objects
        """
        try:
            return self.api.src_app_api_twins_list_twin_devices(twin_id)
        except Exception as e:
            self._handle_error(e, f"list devices for twin {twin_id}")
            raise

    def get_device(self, twin_id: str, device_uuid: str) -> "EdgeDeviceSchema":
        """
        Get a specific edge device by UUID.

        Args:
            twin_id: UUID of the twin
            device_uuid: UUID of the EdgeDevice

        Returns:
            EdgeDeviceSchema with device details
        """
        try:
            return self.api.src_app_api_twins_get_twin_device(twin_id, device_uuid)
        except Exception as e:
            self._handle_error(e, f"get device {device_uuid} for twin {twin_id}")
            raise

    def unpair_device(self, twin_id: str, device_uuid: str) -> Dict[str, str]:
        """
        Unpair (remove) an edge device from this twin.

        Args:
            twin_id: UUID of the twin
            device_uuid: UUID of the EdgeDevice to unpair

        Returns:
            Status message
        """
        try:
            return self.api.src_app_api_twins_unpair_device(twin_id, device_uuid)
        except Exception as e:
            self._handle_error(e, f"unpair device {device_uuid} from twin {twin_id}")
            raise

    def device_heartbeat(
        self,
        twin_id: str,
        fingerprint: str,
        status_data: Optional[Dict[str, Any]] = None,
        ip_address: Optional[str] = None,
    ) -> Dict[str, str]:
        """
        Send a heartbeat for an edge device.

        Called periodically by edge devices to report they are online.

        Args:
            twin_id: UUID of the twin
            fingerprint: Device fingerprint
            status_data: Optional status data (streams, uptime, etc.)
            ip_address: Device IP address (optional)

        Returns:
            Status message
        """
        from cyberwave.rest.models.device_heartbeat_schema import DeviceHeartbeatSchema

        try:
            payload = DeviceHeartbeatSchema(
                fingerprint=fingerprint,
                status_data=status_data,
                ip_address=ip_address,
            )
            return self.api.src_app_api_twins_device_heartbeat(twin_id, payload)
        except Exception as e:
            self._handle_error(e, f"device heartbeat for twin {twin_id}")
            raise
